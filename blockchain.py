import time
from typing import List, Set
from urllib.parse import urlparse

import requests
from block import Block
from transaction import Transaction
from pickle import dumps, loads
from hashlib import sha256

class Blockchain(object):
    def __init__(self):
        self.chain: List[Block] = []
        self.current_transactions = []
        #Nodes in the blockchain network
        self.nodes:Set[str] = set()

        # Create the genesis block
        self.new_block(1, 100)

    def new_block(self, proof: int, prev_hash=None) -> Block:
        """
        Creates a new block in the blockchain.

        Parameters:
        [Optional] prev_hash (int): The hash of the previous block in the chain.
        proof (int): The proof of work generated by the Proof of Work algorithm.

        Returns:
        Block: The newly created block.
        """
        index, timestamp = len(self.chain) + 1, time.time()
        ph_arg = prev_hash or self.hash(self.chain[-1])
        block = Block(index, timestamp,proof, ph_arg)

        # Reset the current_transactions list
        self.current_transactions = []
        # Add the block to the chain
        self.chain.append(block)

        return block
    
    def new_transaction(self, sender:str, recipient:str, amount:int) -> int:
        """
        Adds a transaction to the current_transactions list
        Returns the index of the block that will hold the transaction
        """
        self.current_transactions.append(Transaction(sender, recipient, amount))
        return len(self.chain) + 1
        
    @property
    def last_block(self):
        return self.chain[-1]
    
    @property
    def get_chain(self)-> List[dict]:
        copy_chain = [block.to_dict() for block in self.chain.copy()]
        return copy_chain

    @staticmethod
    def hash(block:Block) -> str:
        """
        Creates a SHA-256 hash of a Block
        :param block: Block
        :return: <str>
        """
        block_str = str(loads(dumps(block))).encode()
        return sha256(block_str).hexdigest()
    
    def proof_of_work(self, last_proof: int) -> int:
        """
        Function the computes the proof of work 
        Simple Proof of Work Algorithm:
         - Find a number p' such that hash(pp') contains leading 4 zeroes, where p is the previous p'
         - p is the previous proof, and p' is the new proof
        :param last_proof: <int>
        :return: <int>
        """
        proof = 0
        while not self.valid_proof(last_proof, proof):
            proof += 1
        
        return proof
    
    def valid_proof(self, last_proof, proof) -> bool:
        """
        Validates the Proof: Does hash(last_proof, proof) contain 4 leading zeroes?
        :param last_proof: <int> Previous Proof
        :param proof: <int> Current Proof
        :return: <bool> True if correct, False if not.
        """
        guess = f'{last_proof}{proof}'.encode()
        guess_hash = sha256(guess).hexdigest()
        return guess_hash[:4] == '0000'
    
    def register_node(self, address:str):
        """
        Registers a new node to the list of nodes
        :param address: <str> Address of the node
        :return: None
        """
        parsed_url = urlparse(address)
        self.nodes.add(parsed_url.netloc)
    
    def valid_chain(self, chain: List[Block]) -> bool:
        """
        Validates the blockchain by checking if it's valid and follows the rules of the Proof of Work algorithm
        :param chain: <List[Block]> The blockchain to validate
        :return: <bool> True if valid, False if not.
        """
        answer = False
        for idx in range(1, len(chain)):
            current_block = chain[idx]
            last_block = chain[idx -1]
            print(f'last block: {last_block}')
            print(f'current block: {current_block}')
            print("\n-----------\n")
            #Check if the hash of the previous block is valid
            if current_block.prev_hash != self.hash(last_block):
                return answer
            #Check if the proof of work is valid
            if not self.valid_proof(last_block.proof, current_block.proof):
                return answer

        return not answer
    
    def resolve_conflicts(self) -> bool:
        answer = False
        neighbours = self.nodes
        new_chain = None
        max_length = len(self.chain)

        for node in self.nodes:
            response = requests.get(f'http://{node}/chain')
            if response.status_code == 200:
                node_length = response.json()['length']
                node_chain = response.json()['chain']

                #Check if the new chain is longer and valid
                if node_length > max_length and self.valid_chain(node_chain):
                    max_length = node_length
                    new_chain = node_chain
                
            if new_chain:
                self.chain = new_chain
                answer = True

        return answer